.-
.-    Copyright (c) 2007 FastMQ Inc.
.-
.-    This file is part of 0MQ.
.-
.-    0MQ is free software; you can redistribute it and/or modify
.-    it under the terms of the GNU General Public License as published by
.-    the Free Software Foundation; either version 3 of the License, or
.-    (at your option) any later version.
.-
.-    0MQ is distributed in the hope that it will be useful,
.-    but WITHOUT ANY WARRANTY; without even the implied warranty of
.-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
.-    GNU General Public License for more details.
.-
.-    You should have received a copy of the GNU General Public License
.-    along with this program.  If not, see <http://www.gnu.org/licenses/>.
.-
.-    Usage: gsl -script:amqp09_base.gsl amqp0-9.xml
.
.macro add_field_format ()
.   type = amqp->domain (name = field.domain).type
.   if type = "bit"
            bool \
.   elsif type = "octet"
            uint8_t \
.   elsif type = "short"
            uint16_t \
.   elsif type = "long"
            uint32_t \
.   elsif type = "longlong"
            uint64_t \
.   elsif type = "timestamp"
            uint64_t \
.   elsif type = "shortstr"
            const shortstr_t \
.   elsif type = "longstr"
            const longstr_t \
.   elsif type = "table"
            const field_table_t &\
.   endif
.endmacro
.
.macro get_padding ()
.   if bit_offset > 0
.       bit_offset = 0
                offset += sizeof (uint8_t);
.   endif
.endmacro
.
.macro get_field ()
.   type = amqp->domain (name = field.domain).type
.   if type <> "bit"
.       get_padding ()
.   endif
.   if bit_offset = 8
.       bit_offset = 0
.   endif
.   if type = "bit"
                bool $(field.name:c) = buf [offset] & (0x1 << $(bit_offset));
.       bit_offset = bit_offset + 1
.   elsif type = "octet"
                uint8_t $(field.name:c) = get_uint8 (buf +offset);
                offset += sizeof (uint8_t);
.   elsif type = "short"
                uint16_t $(field.name:c) = get_uint16 (buf + offset);
                offset += sizeof (uint16_t);
.   elsif type = "long"
                uint32_t $(field.name:c) = get_uint32 (buf + offset);
                offset += sizeof (uint32_t);
.   elsif type = "longlong"
                uint64_t $(field.name:c) = get_uint64 (buf + offset);
                offset += sizeof (uint64_t);
.   elsif type = "timestamp"
                uint64_t $(field.name:c) = get_uint64 (buf + offset);
                offset += sizeof (uint64_t);
.   elsif type = "shortstr"
                shortstr_t $(field.name:c);
                $(field.name:c).size = get_uint8 (buf + offset);
                offset += sizeof (uint8_t);
                $(field.name:c).data = (char*) (buf + offset);
                offset += $(field.name:c).size;
.   elsif type = "longstr"
                longstr_t $(field.name:c);
                $(field.name:c).size = get_uint32 (buf + offset);
                offset += sizeof (uint32_t);
                $(field.name:c).data = (void*) (buf + offset);
                offset += $(field.name:c).size;
.   elsif type = "table"
                field_table_t $(field.name:c);
                get_field_table ($(field.name:c));
.   else
                assert (0);
.endif
.endmacro
.
.macro put_padding ()
.   if bit_offset > 0
.       bit_offset = 0
);
    offset += sizeof (uint8_t);
.   endif
.endmacro
.
.macro put_field ()
.   type = amqp->domain (name = field.domain).type
.   if type <> "bit"
.       put_padding ()
.   endif
.   if type = "bit"
.       if bit_offset = 8
;
.           bit_offset = 0
.       endif
.       if bit_offset = 0
    buf [offset] |= (
.       else
 |
.       endif
        (($(field.name:c)_ ? 1 : 0) << $(bit_offset))\
.       bit_offset = bit_offset + 1
.   elsif type = "octet"
    put_uint8 (buf + offset, $(field.name:c)_);
    offset += sizeof (uint8_t);
.   elsif type = "short"
    put_uint16 (buf + offset, $(field.name:c)_);
    offset += sizeof (uint16_t);
.   elsif type = "long"
    put_uint32 (buf + offset, $(field.name:c)_);
    offset += sizeof (uint32_t);
.   elsif type = "longlong"
    put_uint64 (buf + offset, $(field.name:c)_);
    offset += sizeof (uint64_t);
.   elsif type = "timestamp"
    put_uint64 (buf + offset, $(field.name:c)_);
    offset += sizeof (uint64_t);
.   elsif type = "shortstr"
    put_uint8 (buf + offset, $(field.name:c)_.size);
    offset += sizeof (uint8_t);
    memcpy (buf + offset, $(field.name:c)_.data, $(field.name:c)_.size);
    offset += $(field.name:c)_.size;
.   elsif type = "longstr"
    put_uint32 (buf + offset, $(field.name:c)_.size);
    offset += sizeof (uint32_t);
    memcpy (buf + offset, $(field.name:c)_.data, $(field.name:c)_.size);
    offset += $(field.name:c)_.size;
.   elsif type = "table"
    put_field_table ($(field.name:c)_);
.   else
    assert (0);
.   endif
.endmacro
.
.output "amqp09_base.hpp"
/*
    Copyright (c) 2007 FastMQ Inc.

    This file is part of 0MQ.

    0MQ is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    0MQ is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    This file is generated from $(arg?filename) by $(script) using GSL/4.
*/

#ifndef __ZMQ_AMQP09_BASE_HPP_INCLUDED__
#define __ZMQ_AMQP09_BASE_HPP_INCLUDED__

#include <cstring>
#include <string>
#include <map>
#include <assert.h>
#include <arpa/inet.h>

#include "tcp_socket.hpp"
#include "wire.hpp"

namespace zmq
{

    class amqp09_base_t : public tcp_socket_t
    {
    public:

        struct shortstr_t
        {
            inline shortstr_t () :
                data (NULL),
                size (0)
            {
            }

            inline shortstr_t (const char *data_) :
                data (data_)
            {
                size_t len = strlen (data);
                assert (len <= 0xff);
                size = len;
            }

            const char *data;
            uint8_t size;
        };

        struct longstr_t
        {
            inline longstr_t () :
                data (NULL),
                size (0)
            {
            }

            inline longstr_t (const void *data_, uint32_t size_) :
                data (data_),
                size (size_)
            {
            }

            const void *data;
            uint32_t size;
        };

        typedef std::map<std::string, std::string> field_table_t;

        amqp09_base_t (bool listen, const char *address, uint16_t port);

    protected:

        enum {
.for constant
            amqp_$(constant.name:c) = $(constant.value)$(last ()??''?',')
.endfor
        };

        enum {
.for class
            amqp_$(class.name:c) = $(class.index)$(last ()??''?',')
.endfor
        };

        enum {
.for class
.   for method
            amqp_$(class.name:c)_$(method.name:c) = $(method.index),
.   endfor
.endfor
        };

        void receive_protocol_header ();

        void send_protocol_header ();

        virtual void unexpected () = 0;

.for class
.   if class.name = "message"
.       next
.   endif
.   for method
        virtual void $(class.name:c)_$(method.name:c) (
            uint16_t channel_\
.           for field
,
.           add_field_format ()
$(field.name:c)_\
.       endfor
);

        virtual void send_$(class.name:c)_$(method.name:c) (
            uint16_t channel_\
.       for field
,
.           add_field_format ()
$(field.name:c)_\
.       endfor
);

.   endfor
.endfor
        void dispatch ();

    private:

        void get_field_table (field_table_t &table_);
        void put_field_table (const field_table_t &table_);

        unsigned char buf [amqp_frame_min_size];
        size_t offset;
    };

}

#endif
.close
.output "amqp09_base.cpp"
/*
    Copyright (c) 2007 FastMQ Inc.

    This file is part of 0MQ.

    0MQ is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 3 of the License, or
    (at your option) any later version.

    0MQ is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

    This file is generated from $(arg?filename) by $(script) using GSL/4.
*/

#include "amqp09_base.hpp"

zmq::amqp09_base_t::amqp09_base_t (bool listen, const char *address,
       uint16_t port) :
    tcp_socket_t (listen, address, port)
{
}

.for class
.   if class.name = "message"
.       next
.   endif
.   for method
void zmq::amqp09_base_t::$(class.name:c)_$(method.name:c) (
            uint16_t channel_\
.           for field
,
.           add_field_format ()
$(field.name:c)_\
.       endfor
)
{
    unexpected ();
}

void zmq::amqp09_base_t::send_$(class.name:c)_$(method.name:c) (
            uint16_t channel_\
.           for field
,
.           add_field_format ()
$(field.name:c)_\
.       endfor
)
{
    offset = 0;

    put_uint8 (buf + offset, amqp_frame_method);
    offset += sizeof (uint8_t);
    put_uint16 (buf + offset, channel_);
    offset += sizeof (uint16_t);
    offset += sizeof (uint32_t);
    put_uint16 (buf + offset, amqp_$(class.name:c));
    offset += sizeof (uint16_t);
    put_uint16 (buf + offset, amqp_$(class.name:c)_$(method.name:c));
    offset += sizeof (uint16_t);

.           bit_offset = 0
.           for field
.               put_field ()
.           endfor
.           put_padding ()

    put_uint8 (buf + offset, amqp_frame_end);
    offset += sizeof (uint8_t);
    put_uint32 (buf + sizeof (uint8_t) + sizeof (uint16_t), offset -
        (sizeof (uint8_t) + sizeof (uint16_t) +  sizeof (uint32_t) +
        sizeof (uint8_t)));
    blocking_write (buf, offset);
}

.   endfor
.endfor
void zmq::amqp09_base_t::dispatch ()
{
    offset = 0;
    blocking_read (buf, 7);
    uint8_t frame_type = get_uint8 (buf + offset);
    offset += sizeof (uint8_t);
    uint16_t channel = get_uint16 (buf + offset);
    offset += sizeof (uint16_t);
    uint32_t frame_size = get_uint32 (buf + offset);
    assert (frame_type == amqp_frame_method);

    offset = 0;
    blocking_read (buf, frame_size + 1);
    assert (buf [frame_size] == amqp_frame_end);

    uint16_t class_id = get_uint16 (buf + offset);
    offset += sizeof (uint16_t);
    uint16_t method_id = get_uint16 (buf + offset);
    offset += sizeof (uint16_t);

    switch (class_id) {
.for class
.   if class.name = "message"
.       next
.   endif
    case amqp_$(class.name:c):
        switch (method_id) {
.   for method
        case amqp_$(class.name:c)_$(method.name:c) :
            {
.       for field
.           get_field ()
.       endfor

                $(class.name:c)_$(method.name:c) (
                    channel\
.       for field
,
                    $(field.name:c)\
.       endfor
);

                break;
            }
.   endfor
        default:
            assert (0);
        }
        break;
.endfor
    default:
        assert (0);
    }
}

void zmq::amqp09_base_t::receive_protocol_header ()
{
    blocking_read (buf, 8);
    if (buf [0] != 'A' || buf [1] != 'M' || buf [2] != 'Q' || buf [3] != 'P')
        assert (0);
    if (buf [4] != 1 || buf [5] != 1 || buf [6] != 0 || buf [7] != 9)
        assert (0);
}

void zmq::amqp09_base_t::send_protocol_header ()
{
    unsigned char hdr [] = {'A', 'M', 'Q', 'P', 1, 1, 0, 9};
    blocking_write (hdr, sizeof (hdr));
}

void zmq::amqp09_base_t::get_field_table (field_table_t &table_)
{
    table_.clear ();
    uint32_t table_size = get_uint32 (buf + offset);
    offset += sizeof (uint32_t);
    size_t pos = 0;
    while (pos != table_size) {
        uint8_t field_name_string_size = get_uint8 (buf + offset);
        offset += sizeof (uint8_t);
        std::string field_name ((const char*) (buf + offset),
            field_name_string_size);
        offset += field_name_string_size;
        uint8_t field_type = get_uint8 (buf + offset);
        offset += sizeof (uint8_t);
        std::string field_value;
        switch (field_type) {
        case 'S':
            {
                uint32_t field_value_string_size = get_uint32 (buf + offset);
                offset += sizeof (uint32_t);
                field_value.assign ((const char*) (buf + offset),
                    field_value_string_size);
                offset += field_value_string_size;
                pos += (sizeof (uint8_t) + field_name.size () +
                    sizeof (uint8_t) + sizeof (uint32_t) + field_value.size());
                break;
            }
        default:
            assert (0);
        }    
        table_ [field_name] = field_value;
    }
}

void zmq::amqp09_base_t::put_field_table (const field_table_t &table_)
{
    offset += sizeof (uint32_t);
    size_t table_size = 0;

    for (field_table_t::const_iterator table_it = table_.begin();
          table_it != table_.end(); table_it++ ) {

        put_uint8 (buf + offset, table_it->first.size ());
        offset += sizeof (uint8_t);
        memcpy (buf + offset, table_it->first.c_str (),
           table_it->first.size ());
        offset += table_it->first.size ();
        put_uint8 (buf + offset, 'S');
        offset += sizeof (uint8_t);
        put_uint32 (buf + offset, table_it->second.size ());
        offset += sizeof (uint32_t);
        memcpy (buf + offset, table_it->second.c_str (),
            table_it->second.size ());
        offset += table_it->second.size ();
        table_size += (sizeof (uint8_t) + table_it->first.size () +
            sizeof (uint8_t) + sizeof (uint32_t) +
            table_it->second.size ());
    }
    put_uint32 (buf + offset - table_size - sizeof (uint32_t), table_size);
}

.close
